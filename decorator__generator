###################################装饰器###################################
"""
闭包:内层函数对外层函数（非全局）变量的引用，该内层函数称为闭包函数
函数内部定义的函数称为内部函数
闭包函数的作用：
    保护内存，开启的内存空间,不会随着函数的结束而关闭.
装饰器:
    在不改变被装饰的函数及被装饰函数的执行方式下，给函数添加额外的功能. 用处：日志 本质就是闭包

f1.__doc__          获取函数说明信息
f1.__name__         获取函数名

1.经典闭包函数
    def func():
        name="jerd"
        def inner():
            print(name)
        inner()
    func()
    
2.判断是否为闭包函数的方法：函数名._closure_  结果有cell 就是闭包函数，结果为None，就不是闭包函数
    x="jerd"
    def func3():
        def func2():
            print(x)
        func2()
        print(func2.__closure__)
    func3()                         #None
    
3.装饰器
        import time
        from functools import wraps
      
        def wrapper(func):
            @wraps(func)
            def inner(*args, **kwargs):
                start_time = time.time()
                ret = func(*args,**kwargs)
                end_time = time.time()
                print('----> 执行效率%s' % (end_time - start_time))
                return ret
            return inner

        @wrapper       # func = wrapper(func)
        def func():
            pass
        
        func()          # inner()
        
4.对装饰器加参数
    通过参数决定是否使用装饰器
    import time
    from functools import wraps
    
    def outter(flag):
        def wrapper(func):
            @wraps(func)
            def inner(*args, **kwargs):
                if flag:
                    start_time = time.time()
                    ret = func(*args, **kwargs)
                    end_time = time.time()
                    print('----> %s 函数执行效率%s' % (func.__name__, end_time - start_time))
                else:
                    ret =  func(*args, **kwargs)
                return ret
    
            return inner
    
        return wrapper
    
    @outter(True)
    def func(*args):
        return args[0] + args[1]
    
    func(1,2)
 
5.多个装饰器装饰一个函数:离函数近的装饰器先执行
    from functools import wraps
    
    def wrapper1(func):  #func = f
        @wraps(func)
        def inner1():
            print('wrapper1 ,before func')
            func()                               #执行f()
            print('wrapper1 ,after func')
        return inner1
    def wrapper2(func):                          #func=inner1
        @wraps(func)
        def inner2():
            print('wrapper2 ,before func')
            func()                              #执行inner1（）
            print('wrapper2 ,after func')
        return inner2
    @wrapper2                                  # 此时 f=wrapper2(f) 相当于 inner1=wrapper2(inner1)  此时inner1=inner2
    @wrapper1                                  #离def f()近 先执行这个 此时f=inner1  再执行 @wrapper2
    def f():
        print('in f')
    f()                                        #相当于 inner2()

"""
