###################################生成式#################################
"""
List生成式：
    
    1.列表推导+条件判断
        li = [i for i in range(50) if i % 5 == 0]
    2.列表推导+三目运算   
        li = [ i if i % 5 == 0 else 1 for i in range(1,10) ]
    
    3.嵌套for语句
        data = [["jerrd", "jerd"], [12, 13, 14]]
        li = [ value for array in data for value in array]

Dict生成式：
    1.交换字典的键和值
        a_dict = {"a": 1, "b": 2, "c": 3}

       { value : key  for key, value in a_dict.items() }

    2.大小写Key值合并
        mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}

        case = { key.lower() : mcase.get(key.lower(),0) + mcase.get(key.upper(),0) for key in mcase.keys() }

Set推导式：
    计算列表中每个值的平方，自带去重功能
    s1 = { x**2 for x in [1, -1, 2] }
    
生成器推导式
    li = ( i for i in range(50) if i % 5 == 0 )

"""

将li 转换成
    {
        '北京市': [
                    {'name': '北京市', 'area': '东城区'}, 
                    {'name': '北京市', 'area': '西城区'}, 
                    {'name': '北京市', 'area': '朝阳区'}, 
                    {'name': '北京市', 'area': '海淀区'}
                ], 
        '上海市': [
                    {'name': '上海市', 'area': '浦东新区'}, 
                    {'name': '上海市', 'area': '普陀区'}
                ]
    }


data = {}
li = [
    {"name": "北京市", "area": "东城区"},
    {"name": "北京市", "area": "西城区"},
    {"name": "北京市", "area": "朝阳区"},
    {"name": "北京市", "area": "海淀区"},
    {"name": "上海市", "area": "浦东新区"},
    {"name": "上海市", "area": "普陀区"},
]

for bo in li:
    mbo = data.pop(bo['name'], [])
    mbo.append(bo)
    data[bo['name']] = mbo
    
    

#将list3中的内容以list4中的内容显示出来
list3 = [
    {"name": "北京市", "area": "东城区"},
    {"name": "北京市", "area": "西城区"},
    {"name": "北京市", "area": "朝阳区"},
    {"name": "北京市", "area": "海淀区"},
    {"name": "上海市", "area": "浦东新区"},
    {"name": "上海市", "area": "普陀区"},
]

list4 = [
    {"name": "北京市", "area_list": ["东城区", "西城区", "朝阳区", "海淀区"]},
    {"name": "上海市", "area_list": ["浦东新区", "普陀区"]},
]

result = []
for message in list3:
    for new_message in result:
        if new_message['name'] == message['name']:
            new_message.setdefault('area',[]).append(message[ 'area'])
            break
    else:
        dic = {}
        dic['name'] = message['name']
        dic[ 'area'] = [message[ 'area']]
        result.append(dic)


##################################常用内置函数##############################
"""
map filter zip 返回的是迭代器   sort对原列表进行排序  sorted 返回的是新的列表

1.max 和 min
    1.默认参数key为None
        li = [1, 5, 10, 20]
        print(max(li), min(li)
    
    2.自定义key
        dic={3:20,2:100,5:30}
        1.以Key值比较，取出最大值      max(dic.items(),key=lambda x: x )    #(5, 100)
        2.以Value值比较，取出最大值    max(dic.items(),key=lambda  x : x[1])
        
2.zip()拉链方法。可将两个可迭代对象进行匹配
    可以放置多个可迭代对象,以最少的可迭代对象的个数为基准,返回一个迭代器
    1.可迭代对象长度一致
        li=["name","age"]
        li1=["jerd",18]
        print(dict(zip(li,li1)))
        
    2.可迭代对象长度不一致
    
        li=["name","age","hobby"]
        li1=["jerd",18]
        print(dict(zip(li,li1)))
        
    3.多个迭代对象进行匹配时
        li=["name","age","high"]
        li1=["jerd",18,"hobby"]
        li2=["xdd","book","play"]
        print(list(zip(li,li1,li2)))
        
3.map(func, *iterables)) 可迭代对象的元素，一个一个传给函数
    1.list(map(lambda x : x**2 ,[1,2,3]))
    2.list(map(lambda x,y:x + y,[1,2,3,7],[4,5,6]))  [5, 7, 9]
    
4.filter(function or None, iterable)过滤,取出符合条件的元素
    list(filter(lambda x : x %2==0,[0,1,2,4]))
    
5.sorted() 会形成新的列表，排序必须是列表
    li = ['fsdafsa','fddsaf','qqq','fgasjdlg;dsjfg']
    li2 = sorted(li,key=lambda x: len(x)
    li.sort(key=func)
    print(li, li2) 
    
    将dic中的内容以value值进行降序
        dic = {'math':90, 'chinese':99, 'english':66, 'history': 88, 'political':89,}
        new_dic = dict(sorted(dic.items(),key=lambda x : x[1], reverse=True))

所有排序方法中，sorted的效率是最高的。它使用c代码编写的

6.reduce
    reduce()传入的函数 f 必须接收两个参数,reduce()对list的每个元素反复调用函数f，并返回最终结果值。
    Python3中,reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 fucntools 模块里
    from functools import reduce
    例:编写一个f函数，接收x和y，返回x和y的和：
        res = reduce(lambda x, y : x + y, [1, 3, 5, 7, 9])
        等同于：sum([1, 3, 5, 7, 9])
        
        计算过程：
            先计算头两个元素：f(1, 3)，结果为4；
            再把结果和第3个元素计算：f(4, 5)，结果为9；
            再把结果和第4个元素计算：f(9, 7)，结果为16；
            再把结果和第5个元素计算：f(16, 9)，结果为25；
            由于没有更多的元素了，计算结束，返回结果25。

1.tu1=(('a'),('b')),tu2=(('c'),('d')) 生成列表[{'a':'c'},{'b':'d'}]
    list(map(lambda x, y : {x : y},tu1,tu2))
    
2.tu1(('a',),('b',)),,tu2=(('c',),('d',)) 生成列表[{'a':'c'},{'b':'d'}]
    list(map(lambda x ,y : {x[0] : y[0]}, tu1, tu2))
"""


###################################装饰器###################################
"""
闭包:内层函数对外层函数（非全局）变量的引用，该内层函数称为闭包函数
函数内部定义的函数称为内部函数
闭包函数的作用：
    保护内存，开启的内存空间,不会随着函数的结束而关闭.
装饰器:
    在不改变被装饰的函数及被装饰函数的执行方式下，给函数添加额外的功能. 用处：日志 本质就是闭包

f1.__doc__          获取函数说明信息
f1.__name__         获取函数名

1.经典闭包函数
    def func():
        name="jerd"
        def inner():
            print(name)
        inner()
    func()
    
2.判断是否为闭包函数的方法：函数名._closure_  结果有cell 就是闭包函数，结果为None，就不是闭包函数
    x="jerd"
    def func3():
        def func2():
            print(x)
        func2()
        print(func2.__closure__)
    func3()                         #None
    
3.装饰器
        import time
        from functools import wraps
      
        def wrapper(func):
            @wraps(func)
            def inner(*args, **kwargs):
                start_time = time.time()
                ret = func(*args,**kwargs)
                end_time = time.time()
                print('----> 执行效率%s' % (end_time - start_time))
                return ret
            return inner

        @wrapper       # func = wrapper(func)
        def func():
            pass
        
        func()          # inner()
        
4.对装饰器加参数
    通过参数决定是否使用装饰器
    import time
    from functools import wraps
    
    def outter(flag):
        def wrapper(func):
            @wraps(func)
            def inner(*args, **kwargs):
                if flag:
                    start_time = time.time()
                    ret = func(*args, **kwargs)
                    end_time = time.time()
                    print('----> %s 函数执行效率%s' % (func.__name__, end_time - start_time))
                else:
                    ret =  func(*args, **kwargs)
                return ret
    
            return inner
    
        return wrapper
    
    @outter(True)
    def func(*args):
        return args[0] + args[1]
    
    func(1,2)
 
5.多个装饰器装饰一个函数:离函数近的装饰器先执行
    from functools import wraps
    
    def wrapper1(func):  #func = f
        @wraps(func)
        def inner1():
            print('wrapper1 ,before func')
            func()                               #执行f()
            print('wrapper1 ,after func')
        return inner1
    def wrapper2(func):                          #func=inner1
        @wraps(func)
        def inner2():
            print('wrapper2 ,before func')
            func()                              #执行inner1（）
            print('wrapper2 ,after func')
        return inner2
    @wrapper2                                  # 此时 f=wrapper2(f) 相当于 inner1=wrapper2(inner1)  此时inner1=inner2
    @wrapper1                                  #离def f()近 先执行这个 此时f=inner1  再执行 @wrapper2
    def f():
        print('in f')
    f()                                        #相当于 inner2()

"""
